name: Generate osu! skinhub-basic skins index

on:
  push:
    branches:
      - "**"
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  generate-skins-index:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine repository metadata
        id: meta
        run: |
          set -e

          # OWNER and REPO from GITHUB_REPOSITORY (format: owner/repo)
          OWNER="${GITHUB_REPOSITORY%%/*}"
          REPO="${GITHUB_REPOSITORY##*/}"

          # Event name
          EVENT_NAME="${GITHUB_EVENT_NAME}"

          # Default branch from event payload when available
          DEFAULT_BRANCH="$(jq -r '.repository.default_branch // empty' "$GITHUB_EVENT_PATH" || true)"

          BRANCH=""

          if [ -n "$DEFAULT_BRANCH" ]; then
            # Prefer default_branch from event when present
            BRANCH="$DEFAULT_BRANCH"
          else
            if [ "$EVENT_NAME" = "push" ]; then
              # For push, derive the branch name from GITHUB_REF when default_branch is unavailable
              # GITHUB_REF example: refs/heads/main
              if [ -n "$GITHUB_REF" ]; then
                BRANCH="${GITHUB_REF#refs/heads/}"
              fi
            elif [ "$EVENT_NAME" = "pull_request" ]; then
              # For PR, use head ref for validation only
              BRANCH="$(jq -r '.pull_request.head.ref' "$GITHUB_EVENT_PATH")"
            fi
          fi

          # Final fallback: use current HEAD short ref if still empty
          if [ -z "$BRANCH" ]; then
            BRANCH="$(git rev-parse --abbrev-ref HEAD)"
          fi

          echo "OWNER=$OWNER" >> "$GITHUB_OUTPUT"
          echo "REPO=$REPO" >> "$GITHUB_OUTPUT"
          echo "BRANCH=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Generate skins index content
        id: generate
        run: |
          set -e

          OWNER="${{ steps.meta.outputs.OWNER }}"
          REPO="${{ steps.meta.outputs.REPO }}"
          BRANCH="${{ steps.meta.outputs.BRANCH }}"

          SKINS_DIR="skins"

          # Collect eligible skin files: only direct children of skins/ with .osk or .zip (case-insensitive)
          if [ -d "$SKINS_DIR" ]; then
            mapfile -t FILES < <(
              find "$SKINS_DIR" -maxdepth 1 -mindepth 1 -type f \
                \( -iname "*.osk" -o -iname "*.zip" \) -printf "%f\n" \
              | python - << 'PY'
import sys
files = [line.strip() for line in sys.stdin if line.strip()]
# Sort case-insensitive with case-sensitive tiebreaker
files.sort(key=lambda s: (s.lower(), s))
for f in files:
    print(f)
PY
            )
          else
            FILES=()
          fi

          # Function to encode filename for URL
          urlencode() {
            python - "$1" << 'PY'
import sys, urllib.parse
s = sys.argv[1]
print(urllib.parse.quote(s))
PY
          }

          # Function to convert filename to skin name
          to_skin_name() {
            python - "$1" << 'PY'
import sys, re, os
filename = sys.argv[1]

# Separate name and extension
name, ext = os.path.splitext(filename)

# Replace underscores with spaces
name = name.replace('_', ' ')

# Replace remaining dots with spaces
name = name.replace('.', ' ')

# Collapse multiple spaces
name = re.sub(r'\s+', ' ', name).strip()

# Simple title-style capitalization:
# - Preserve dashes and bracket content as-is structurally
def title_word(word: str) -> str:
    if not word:
        return word
    # If the word starts with '[', '(', '{', keep bracket and title-case the next char if alpha
    if word[0] in '[({':
        if len(word) > 1 and word[1].isalpha():
            return word[0] + word[1].upper() + word[2:]
        return word
    # For other words, upper-case first alpha, keep rest as-is
    for i, ch in enumerate(word):
        if ch.isalpha():
            return word[:i] + ch.upper() + word[i+1:]
    return word

parts = name.split(' ')
titled_parts = [title_word(p) for p in parts]
result = ' '.join(titled_parts)

print(result)
PY
          }

          OUTPUT_FILE="skins.md"

          {
            echo "# osu! skinhub-basic skins index"
            echo
            echo "> This file is auto-generated by .github/workflows/generate-skins-index.yml. Do not edit manually."
            echo
            echo "This index lists all osu! skins stored as .osk or .zip archives directly under the skins/ directory, with direct GitHub download links that work for this repository and its forks."
            echo
            echo "| Skin | Filename | Download |"
            echo "| --- | --- | --- |"

            for f in "${FILES[@]}"; do
              [ -n "$f" ] || continue
              skin_name="$(to_skin_name "$f")"
              encoded="$(urlencode "$f")"
              download_url="https://github.com/${OWNER}/${REPO}/raw/${BRANCH}/skins/${encoded}"
              echo "| ${skin_name} | ${f} | [Download](${download_url}) |"
            done
          } > "$OUTPUT_FILE"

          # Expose path for later steps
          echo "output_file=$OUTPUT_FILE" >> "$GITHUB_OUTPUT"

      - name: Handle push/workflow_dispatch - commit and push if changed
        if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
        run: |
          set -e

          OUTPUT_FILE="${{ steps.generate.outputs.output_file }}"

          if ! git diff --quiet -- "$OUTPUT_FILE"; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

            git add "$OUTPUT_FILE"
            git commit -m "chore: update skins index" || exit 0
            git push
          fi

      - name: Handle pull_request - validate only
        if: github.event_name == 'pull_request'
        run: |
          set -e

          OUTPUT_FILE="${{ steps.generate.outputs.output_file }}"

          # If there is any diff in skins.md compared to the regenerated version, fail
          if ! git diff --quiet -- "$OUTPUT_FILE"; then
            echo "skins.md is out of date. It is auto-generated by .github/workflows/generate-skins-index.yml and must match the generated content."
            exit 1
          fi